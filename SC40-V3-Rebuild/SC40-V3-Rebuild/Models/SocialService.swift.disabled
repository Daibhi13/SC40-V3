import Foundation
import Combine

// Type aliases to match SocialModels.swift definitions
typealias LeaderboardType = LeaderboardCategory
typealias LeaderboardPeriod = LeaderboardTimeframe

// Missing types that need to be defined
struct FriendRequest: Identifiable, Codable {
    let id: UUID
    let fromUserId: UUID
    let toUserId: UUID
    let message: String?
    let status: String
    let createdAt: Date
}

struct ChallengeProgress: Codable {
    let challengeId: UUID
    let userId: UUID
    let currentValue: Double
    let targetValue: Double
    let completedAt: Date?
}

struct SocialNotification: Identifiable, Codable {
    let id: UUID
    let userId: UUID
    let type: String
    let title: String
    let message: String
    let isRead: Bool
    let createdAt: Date
}

struct ChallengeCreate: Codable {
    let name: String
    let description: String
    let type: ChallengeType
    let targetValue: Double
    let startDate: Date
    let endDate: Date
}

struct SocialUserUpdate: Codable {
    let displayName: String?
    let bio: String?
    let avatarURL: String?
}

struct ActivityType: Codable {
    let name: String
    let category: String
}

// MARK: - Social Service Protocol

protocol SocialServiceProtocol {
    // User Management
    func getCurrentUser() async throws -> SocialUser
    func updateProfile(_ updates: SocialUserUpdate) async throws -> SocialUser
    func searchUsers(query: String) async throws -> [SocialUser]
    
    // Friend Management
    func sendFriendRequest(to userId: String, message: String?) async throws -> FriendRequest
    func respondToFriendRequest(_ requestId: String, accept: Bool) async throws
    func getFriends() async throws -> [SocialUser]
    func getFriendRequests() async throws -> [FriendRequest]
    func removeFriend(_ userId: String) async throws
    
    // Challenge Management
    func createChallenge(_ challenge: ChallengeCreate) async throws -> Challenge
    func joinChallenge(_ challengeId: String) async throws
    func leaveChallenge(_ challengeId: String) async throws
    func getActiveChallenges() async throws -> [Challenge]
    func getChallengeProgress(_ challengeId: String) async throws -> ChallengeProgress
    func updateChallengeProgress(_ challengeId: String, value: Double) async throws
    
    // Leaderboards
    func getLeaderboard(_ type: LeaderboardType, period: LeaderboardPeriod) async throws -> Leaderboard
    func getUserRank(in leaderboardId: String) async throws -> Int?
    
    // Activity Feed
    func getActivityFeed(limit: Int) async throws -> [SocialActivity]
    func postActivity(_ activity: ActivityCreate) async throws -> SocialActivity
    func likeActivity(_ activityId: String) async throws
    func commentOnActivity(_ activityId: String, text: String) async throws
    
    // Notifications
    func getNotifications() async throws -> [SocialNotification]
    func markNotificationAsRead(_ notificationId: String) async throws
}

// MARK: - Data Transfer Objects

struct SocialUserUpdate: Codable {
    let displayName: String?
    let isPublic: Bool?
    let profileImageData: Data?
}

struct ChallengeCreate: Codable {
    let title: String
    let description: String
    let type: ChallengeType
    let startDate: Date
    let endDate: Date
    let targetValue: Double?
    let targetUnit: String?
    let isPublic: Bool
    let maxParticipants: Int?
    let rules: [String]
}

struct ActivityCreate: Codable {
    let type: ActivityType
    let title: String
    let description: String
    let metadata: [String: String]
    let imageData: Data?
    let isPublic: Bool
}

// MARK: - Mock Social Service Implementation

class MockSocialService: SocialServiceProtocol, ObservableObject {
    
    @Published var currentUser: SocialUser?
    @Published var friends: [SocialUser] = []
    @Published var activeChallenges: [Challenge] = []
    @Published var notifications: [SocialNotification] = []
    
    private var mockUsers: [SocialUser] = []
    private var mockChallenges: [Challenge] = []
    private var mockActivities: [SocialActivity] = []
    private var mockLeaderboards: [Leaderboard] = []
    
    init() {
        setupMockData()
    }
    
    // MARK: - User Management
    
    func getCurrentUser() async throws -> SocialUser {
        if let user = currentUser {
            return user
        }
        
        // Create a default user if none exists
        let user = SocialUser(
            id: UUID().uuidString,
            username: "user_\(Int.random(in: 1000...9999))",
            displayName: "Sprint Runner",
            email: "user@example.com",
            level: "Intermediate",
            challengesWon: 5,
            totalWorkouts: 23
        )
        
        await MainActor.run {
            self.currentUser = user
        }
        
        return user
    }
    
    func updateProfile(_ updates: SocialUserUpdate) async throws -> SocialUser {
        guard var user = currentUser else {
            throw SocialError.notAuthenticated
        }
        
        // Apply updates
        if let displayName = updates.displayName {
            user = SocialUser(
                id: user.id,
                username: user.username,
                displayName: displayName,
                email: user.email,
                profileImageURL: user.profileImageURL,
                isPublic: updates.isPublic ?? user.isPublic,
                personalBest40yd: user.personalBest40yd,
                level: user.level,
                joinedDate: user.joinedDate,
                lastActiveDate: Date(),
                friendsCount: user.friendsCount,
                challengesWon: user.challengesWon,
                totalWorkouts: user.totalWorkouts
            )
        }
        
        await MainActor.run {
            self.currentUser = user
        }
        
        return user
    }
    
    func searchUsers(query: String) async throws -> [SocialUser] {
        return mockUsers.filter { user in
            user.username.localizedCaseInsensitiveContains(query) ||
            user.displayName.localizedCaseInsensitiveContains(query)
        }
    }
    
    // MARK: - Friend Management
    
    func sendFriendRequest(to userId: String, message: String?) async throws -> FriendRequest {
        guard let currentUser = currentUser else {
            throw SocialError.notAuthenticated
        }
        
        let request = FriendRequest(
            id: UUID().uuidString,
            fromUserId: currentUser.id,
            toUserId: userId,
            status: .pending,
            requestDate: Date(),
            responseDate: nil,
            message: message
        )
        
        return request
    }
    
    func respondToFriendRequest(_ requestId: String, accept: Bool) async throws {
        // Mock implementation - would update request status
        if accept {
            // Add friend to friends list
            let mockFriend = SocialUser(
                id: UUID().uuidString,
                username: "new_friend",
                displayName: "New Friend",
                level: "Beginner"
            )
            
            await MainActor.run {
                self.friends.append(mockFriend)
            }
        }
    }
    
    func getFriends() async throws -> [SocialUser] {
        return friends
    }
    
    func getFriendRequests() async throws -> [FriendRequest] {
        // Return mock pending requests
        return []
    }
    
    func removeFriend(_ userId: String) async throws {
        await MainActor.run {
            self.friends.removeAll { $0.id == userId }
        }
    }
    
    // MARK: - Challenge Management
    
    func createChallenge(_ challenge: ChallengeCreate) async throws -> Challenge {
        guard let currentUser = currentUser else {
            throw SocialError.notAuthenticated
        }
        
        let newChallenge = Challenge(
            id: UUID().uuidString,
            title: challenge.title,
            description: challenge.description,
            type: challenge.type,
            creatorId: currentUser.id,
            participantIds: [currentUser.id],
            status: .pending,
            createdDate: Date(),
            startDate: challenge.startDate,
            endDate: challenge.endDate,
            targetValue: challenge.targetValue,
            targetUnit: challenge.targetUnit,
            isPublic: challenge.isPublic,
            maxParticipants: challenge.maxParticipants,
            entryFee: nil,
            prizePool: nil,
            rules: challenge.rules,
            progress: [:]
        )
        
        await MainActor.run {
            self.activeChallenges.append(newChallenge)
        }
        
        return newChallenge
    }
    
    func joinChallenge(_ challengeId: String) async throws {
        guard let currentUser = currentUser else {
            throw SocialError.notAuthenticated
        }
        
        await MainActor.run {
            if let index = self.activeChallenges.firstIndex(where: { $0.id == challengeId }) {
                var challenge = self.activeChallenges[index]
                if !challenge.participantIds.contains(currentUser.id) {
                    var updatedParticipants = challenge.participantIds
                    updatedParticipants.append(currentUser.id)
                    
                    // Create updated challenge (since Challenge is immutable)
                    let updatedChallenge = Challenge(
                        id: challenge.id,
                        title: challenge.title,
                        description: challenge.description,
                        type: challenge.type,
                        creatorId: challenge.creatorId,
                        participantIds: updatedParticipants,
                        status: challenge.status,
                        createdDate: challenge.createdDate,
                        startDate: challenge.startDate,
                        endDate: challenge.endDate,
                        targetValue: challenge.targetValue,
                        targetUnit: challenge.targetUnit,
                        isPublic: challenge.isPublic,
                        maxParticipants: challenge.maxParticipants,
                        entryFee: challenge.entryFee,
                        prizePool: challenge.prizePool,
                        rules: challenge.rules,
                        progress: challenge.progress
                    )
                    
                    self.activeChallenges[index] = updatedChallenge
                }
            }
        }
    }
    
    func leaveChallenge(_ challengeId: String) async throws {
        guard let currentUser = currentUser else {
            throw SocialError.notAuthenticated
        }
        
        await MainActor.run {
            if let index = self.activeChallenges.firstIndex(where: { $0.id == challengeId }) {
                let challenge = self.activeChallenges[index]
                let updatedParticipants = challenge.participantIds.filter { $0 != currentUser.id }
                
                if updatedParticipants.isEmpty {
                    // Remove challenge if no participants left
                    self.activeChallenges.remove(at: index)
                } else {
                    // Update challenge with remaining participants
                    let updatedChallenge = Challenge(
                        id: challenge.id,
                        title: challenge.title,
                        description: challenge.description,
                        type: challenge.type,
                        creatorId: challenge.creatorId,
                        participantIds: updatedParticipants,
                        status: challenge.status,
                        createdDate: challenge.createdDate,
                        startDate: challenge.startDate,
                        endDate: challenge.endDate,
                        targetValue: challenge.targetValue,
                        targetUnit: challenge.targetUnit,
                        isPublic: challenge.isPublic,
                        maxParticipants: challenge.maxParticipants,
                        entryFee: challenge.entryFee,
                        prizePool: challenge.prizePool,
                        rules: challenge.rules,
                        progress: challenge.progress
                    )
                    
                    self.activeChallenges[index] = updatedChallenge
                }
            }
        }
    }
    
    func getActiveChallenges() async throws -> [Challenge] {
        return activeChallenges
    }
    
    func getChallengeProgress(_ challengeId: String) async throws -> ChallengeProgress {
        guard let currentUser = currentUser else {
            throw SocialError.notAuthenticated
        }
        
        return ChallengeProgress(
            userId: currentUser.id,
            challengeId: challengeId,
            currentValue: Double.random(in: 4.0...6.0),
            bestValue: Double.random(in: 4.0...5.5),
            completedSessions: ["session1", "session2"],
            rank: Int.random(in: 1...10)
        )
    }
    
    func updateChallengeProgress(_ challengeId: String, value: Double) async throws {
        // Mock implementation - would update progress in backend
    }
    
    // MARK: - Leaderboards
    
    func getLeaderboard(_ type: LeaderboardType, period: LeaderboardPeriod) async throws -> Leaderboard {
        return mockLeaderboards.first { $0.type == type } ?? createMockLeaderboard(type: type, period: period)
    }
    
    func getUserRank(in leaderboardId: String) async throws -> Int? {
        guard let currentUser = currentUser else { return nil }
        
        if let leaderboard = mockLeaderboards.first(where: { $0.id == leaderboardId }) {
            return leaderboard.userRank(userId: currentUser.id)
        }
        
        return Int.random(in: 1...100)
    }
    
    // MARK: - Activity Feed
    
    func getActivityFeed(limit: Int) async throws -> [SocialActivity] {
        return Array(mockActivities.prefix(limit))
    }
    
    func postActivity(_ activity: ActivityCreate) async throws -> SocialActivity {
        guard let currentUser = currentUser else {
            throw SocialError.notAuthenticated
        }
        
        let newActivity = SocialActivity(
            id: UUID().uuidString,
            userId: currentUser.id,
            type: activity.type,
            title: activity.title,
            description: activity.description,
            timestamp: Date(),
            metadata: activity.metadata,
            imageURL: nil,
            isPublic: activity.isPublic,
            likes: [],
            comments: []
        )
        
        await MainActor.run {
            self.mockActivities.insert(newActivity, at: 0)
        }
        
        return newActivity
    }
    
    func likeActivity(_ activityId: String) async throws {
        // Mock implementation - would toggle like status
    }
    
    func commentOnActivity(_ activityId: String, text: String) async throws {
        // Mock implementation - would add comment
    }
    
    // MARK: - Notifications
    
    func getNotifications() async throws -> [SocialNotification] {
        return notifications
    }
    
    func markNotificationAsRead(_ notificationId: String) async throws {
        await MainActor.run {
            if let index = self.notifications.firstIndex(where: { $0.id == notificationId }) {
                let notification = self.notifications[index]
                let updatedNotification = SocialNotification(
                    id: notification.id,
                    userId: notification.userId,
                    type: notification.type,
                    title: notification.title,
                    message: notification.message,
                    timestamp: notification.timestamp,
                    isRead: true,
                    actionURL: notification.actionURL,
                    imageURL: notification.imageURL,
                    metadata: notification.metadata
                )
                self.notifications[index] = updatedNotification
            }
        }
    }
    
    // MARK: - Mock Data Setup
    
    private func setupMockData() {
        // Create mock users
        mockUsers = [
            SocialUser(id: "1", username: "speedster_23", displayName: "Speed Demon", level: "Advanced", personalBest40yd: 4.25, challengesWon: 15, totalWorkouts: 87),
            SocialUser(id: "2", username: "track_star", displayName: "Track Star", level: "Expert", personalBest40yd: 4.18, challengesWon: 23, totalWorkouts: 134),
            SocialUser(id: "3", username: "sprint_rookie", displayName: "Sprint Rookie", level: "Beginner", personalBest40yd: 5.12, challengesWon: 2, totalWorkouts: 15)
        ]
        
        // Create mock challenges
        let challenge1 = Challenge(
            id: "challenge1",
            title: "Weekly Sprint Challenge",
            description: "Best 40-yard time this week",
            type: .sprint40Yard,
            creatorId: "1",
            participantIds: ["1", "2", "3"],
            status: .active,
            createdDate: Date().addingTimeInterval(-86400 * 2),
            startDate: Date().addingTimeInterval(-86400),
            endDate: Date().addingTimeInterval(86400 * 5),
            targetValue: 4.5,
            targetUnit: "seconds",
            isPublic: true,
            maxParticipants: 10,
            entryFee: nil,
            prizePool: nil,
            rules: ["Official 40-yard distance", "GPS timing required"],
            progress: [:]
        )
        
        activeChallenges = [challenge1]
        
        // Create mock activities
        mockActivities = [
            SocialActivity(
                id: "activity1",
                userId: "1",
                type: .personalBestSet,
                title: "New Personal Best!",
                description: "Just ran a 4.25s 40-yard sprint!",
                timestamp: Date().addingTimeInterval(-3600),
                metadata: ["time": "4.25", "distance": "40"],
                imageURL: nil,
                isPublic: true,
                likes: ["2", "3"],
                comments: []
            )
        ]
        
        // Create mock leaderboard
        mockLeaderboards = [
            createMockLeaderboard(type: .globalSprint40, period: .weekly)
        ]
        
        // Create mock notifications
        notifications = [
            SocialNotification(
                id: "notif1",
                userId: "current_user",
                type: .challengeInvitation,
                title: "Challenge Invitation",
                message: "speedster_23 invited you to join 'Weekly Sprint Challenge'",
                timestamp: Date().addingTimeInterval(-1800),
                isRead: false,
                actionURL: "app://challenge/challenge1",
                imageURL: nil,
                metadata: ["challengeId": "challenge1"]
            )
        ]
    }
    
    private func createMockLeaderboard(type: LeaderboardType, period: LeaderboardPeriod) -> Leaderboard {
        let entries = [
            LeaderboardEntry(
                id: "entry1",
                userId: "2",
                username: "track_star",
                displayName: "Track Star",
                profileImageURL: nil,
                score: 4.18,
                rank: 1,
                change: 0,
                value: "4.18s",
                achievedDate: Date().addingTimeInterval(-3600),
                badgeImageURL: nil
            ),
            LeaderboardEntry(
                id: "entry2",
                userId: "1",
                username: "speedster_23",
                displayName: "Speed Demon",
                profileImageURL: nil,
                score: 4.25,
                rank: 2,
                change: 1,
                value: "4.25s",
                achievedDate: Date().addingTimeInterval(-7200),
                badgeImageURL: nil
            )
        ]
        
        return Leaderboard(
            id: UUID().uuidString,
            name: type.displayName,
            type: type,
            period: period,
            entries: entries,
            lastUpdated: Date(),
            isPublic: true,
            seasonId: nil
        )
    }
}

// MARK: - Error Types

enum SocialError: LocalizedError {
    case notAuthenticated
    case networkError(String)
    case invalidData
    case userNotFound
    case challengeNotFound
    case permissionDenied
    
    var errorDescription: String? {
        switch self {
        case .notAuthenticated:
            return "User not authenticated"
        case .networkError(let message):
            return "Network error: \(message)"
        case .invalidData:
            return "Invalid data received"
        case .userNotFound:
            return "User not found"
        case .challengeNotFound:
            return "Challenge not found"
        case .permissionDenied:
            return "Permission denied"
        }
    }
}
