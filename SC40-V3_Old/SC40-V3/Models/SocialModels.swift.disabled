//
//  SocialModels.swift
//  SC40-V3
//
//  Created by Assistant on Social Features Implementation
//

import Foundation
import Combine

// MARK: - Social User Models

struct SocialUser: Identifiable, Codable {
    let id: UUID
    var username: String
    var displayName: String
    var avatarURL: String?
    var personalBest: Double?
    var totalSprints: Int
    var joinDate: Date
    var isPrivate: Bool
    var location: String?
    
    // Computed properties for display
    var bestTimeFormatted: String {
        guard let pb = personalBest else { return "No time set" }
        return String(format: "%.2f sec", pb)
    }
    
    var sprintsCountText: String {
        return "\(totalSprints) sprint\(totalSprints == 1 ? "" : "s")"
    }
    
    init(id: UUID = UUID(), username: String, displayName: String, avatarURL: String? = nil, personalBest: Double? = nil, totalSprints: Int = 0, joinDate: Date = Date(), isPrivate: Bool = false, location: String? = nil) {
        self.id = id
        self.username = username
        self.displayName = displayName
        self.avatarURL = avatarURL
        self.personalBest = personalBest
        self.totalSprints = totalSprints
        self.joinDate = joinDate
        self.isPrivate = isPrivate
        self.location = location
    }
}

// MARK: - Challenge Models

enum ChallengeType: String, CaseIterable, Codable {
    case speed = "speed"
    case distance = "distance"
    case consistency = "consistency"
    case improvement = "improvement"
    
    var displayName: String {
        switch self {
        case .speed: return "Speed Challenge"
        case .distance: return "Distance Challenge"
        case .consistency: return "Consistency Challenge"
        case .improvement: return "Improvement Challenge"
        }
    }
    
    var description: String {
        switch self {
        case .speed: return "Achieve the fastest 40-yard time"
        case .distance: return "Complete the most total distance"
        case .consistency: return "Maintain consistent training"
        case .improvement: return "Show the most improvement"
        }
    }
}

enum ChallengeStatus: String, Codable {
    case active = "active"
    case completed = "completed"
    case failed = "failed"
    case upcoming = "upcoming"
}

struct Challenge: Identifiable, Codable {
    let id: UUID
    var title: String
    var description: String
    var type: ChallengeType
    var status: ChallengeStatus
    var startDate: Date
    var endDate: Date
    var participants: [UUID] // User IDs
    var targetValue: Double // Target time, distance, etc.
    var currentProgress: Double
    var createdBy: UUID // User ID
    var isPublic: Bool
    var prize: String?
    
    // Computed properties
    var progressPercentage: Double {
        guard targetValue > 0 else { return 0 }
        return min(currentProgress / targetValue * 100, 100)
    }
    
    var isActive: Bool {
        return status == .active && Date() >= startDate && Date() <= endDate
    }
    
    var daysRemaining: Int {
        let calendar = Calendar.current
        return calendar.dateComponents([.day], from: Date(), to: endDate).day ?? 0
    }
    
    init(id: UUID = UUID(), title: String, description: String, type: ChallengeType, status: ChallengeStatus = .upcoming, startDate: Date, endDate: Date, participants: [UUID] = [], targetValue: Double, currentProgress: Double = 0, createdBy: UUID, isPublic: Bool = true, prize: String? = nil) {
        self.id = id
        self.title = title
        self.description = description
        self.type = type
        self.status = status
        self.startDate = startDate
        self.endDate = endDate
        self.participants = participants
        self.targetValue = targetValue
        self.currentProgress = currentProgress
        self.createdBy = createdBy
        self.isPublic = isPublic
        self.prize = prize
    }
}

// MARK: - Leaderboard Models

enum LeaderboardCategory: String, CaseIterable, Codable {
    case overall = "overall"
    case speed = "speed"
    case distance = "distance"
    case improvement = "improvement"
    
    var displayName: String {
        switch self {
        case .overall: return "Overall"
        case .speed: return "Speed"
        case .distance: return "Distance"
        case .improvement: return "Improvement"
        }
    }
}

enum LeaderboardTimeframe: String, CaseIterable, Codable {
    case daily = "daily"
    case weekly = "weekly"
    case monthly = "monthly"
    case allTime = "all_time"
    
    var displayName: String {
        switch self {
        case .daily: return "Daily"
        case .weekly: return "Weekly"
        case .monthly: return "Monthly"
        case .allTime: return "All Time"
        }
    }
}

struct LeaderboardEntry: Identifiable, Codable {
    let id: UUID
    let userId: UUID
    var username: String
    var displayName: String
    var avatarURL: String?
    var rank: Int
    var score: Double
    var category: LeaderboardCategory
    var timeframe: LeaderboardTimeframe
    var lastUpdated: Date
    
    // Computed properties
    var scoreFormatted: String {
        switch category {
        case .speed:
            return String(format: "%.2f sec", score)
        case .distance:
            return String(format: "%.1f yards", score)
        case .improvement:
            return String(format: "%.2f%%", score)
        case .overall:
            return String(format: "%.0f pts", score)
        }
    }
    
    var rankDisplayText: String {
        switch rank {
        case 1: return "ðŸ¥‡ 1st"
        case 2: return "ðŸ¥ˆ 2nd"
        case 3: return "ðŸ¥‰ 3rd"
        default: return "#\(rank)"
        }
    }
    
    init(id: UUID = UUID(), userId: UUID, username: String, displayName: String, avatarURL: String? = nil, rank: Int, score: Double, category: LeaderboardCategory, timeframe: LeaderboardTimeframe, lastUpdated: Date = Date()) {
        self.id = id
        self.userId = userId
        self.username = username
        self.displayName = displayName
        self.avatarURL = avatarURL
        self.rank = rank
        self.score = score
        self.category = category
        self.timeframe = timeframe
        self.lastUpdated = lastUpdated
    }
}

struct Leaderboard: Identifiable, Codable {
    let id: UUID
    var category: LeaderboardCategory
    var timeframe: LeaderboardTimeframe
    var entries: [LeaderboardEntry]
    var lastUpdated: Date
    
    init(id: UUID = UUID(), category: LeaderboardCategory, timeframe: LeaderboardTimeframe, entries: [LeaderboardEntry] = [], lastUpdated: Date = Date()) {
        self.id = id
        self.category = category
        self.timeframe = timeframe
        self.entries = entries.sorted { $0.rank < $1.rank }
        self.lastUpdated = lastUpdated
    }
}

// MARK: - Social Activity Models

enum SocialActivityType: String, CaseIterable, Codable {
    case friendRequest = "friend_request"
    case challengeInvite = "challenge_invite"
    case personalBest = "personal_best"
    case challengeCompleted = "challenge_completed"
    case rankImprovement = "rank_improvement"
    case workoutCompleted = "workout_completed"
}

struct SocialActivity: Identifiable, Codable {
    let id: UUID
    let userId: UUID
    var username: String
    var displayName: String
    var avatarURL: String?
    var type: SocialActivityType
    var title: String
    var description: String
    var timestamp: Date
    var isRead: Bool
    var relatedId: UUID? // Challenge ID, User ID, etc.
    
    // Computed properties
    var timeAgoText: String {
        let formatter = RelativeDateTimeFormatter()
        formatter.unitsStyle = .short
        return formatter.localizedString(for: timestamp, relativeTo: Date())
    }
    
    var iconName: String {
        switch type {
        case .friendRequest: return "person.badge.plus"
        case .challengeInvite: return "trophy"
        case .personalBest: return "stopwatch"
        case .challengeCompleted: return "checkmark.circle"
        case .rankImprovement: return "arrow.up.circle"
        case .workoutCompleted: return "figure.run"
        }
    }
    
    init(id: UUID = UUID(), userId: UUID, username: String, displayName: String, avatarURL: String? = nil, type: SocialActivityType, title: String, description: String, timestamp: Date = Date(), isRead: Bool = false, relatedId: UUID? = nil) {
        self.id = id
        self.userId = userId
        self.username = username
        self.displayName = displayName
        self.avatarURL = avatarURL
        self.type = type
        self.title = title
        self.description = description
        self.timestamp = timestamp
        self.isRead = isRead
        self.relatedId = relatedId
    }
}

// MARK: - Social Service Protocol

@MainActor
// Temporarily disabled - conflicts with SocialService.swift
// protocol SocialServiceProtocol: ObservableObject {
//     var friends: [SocialUser] { get }
//     var activeChallenges: [Challenge] { get }
//     var leaderboards: [Leaderboard] { get }
//     var activityFeed: [SocialActivity] { get }
//     var isLoading: Bool { get }
//     var error: SocialError? { get }
//     
//     func loadFriends() async
//     func addFriend(username: String) async throws
//     func removeFriend(userId: UUID) async throws
//     func loadChallenges() async
//     func createChallenge(_ challenge: Challenge) async throws
//     func joinChallenge(challengeId: UUID) async throws
//     func loadLeaderboards() async
//     func loadActivityFeed() async
//     func markActivityAsRead(activityId: UUID) async
// }

// MARK: - Social Errors (Disabled - conflicts with SocialService.swift)

// enum SocialError: LocalizedError {
//     case networkUnavailable
//     case userNotFound
//     case challengeNotFound
//     case alreadyFriends
//     case challengeFull
//     case invalidCredentials
//     case serverError
//     case unknown
//     
//     var errorDescription: String? {
//         switch self {
//         case .networkUnavailable:
//             return "Network connection unavailable"
//         case .userNotFound:
            return "User not found"
        case .challengeNotFound:
            return "Challenge not found"
        case .alreadyFriends:
            return "Already friends with this user"
        case .challengeFull:
//         return "Challenge is full"
//     case .invalidCredentials:
//         return "Invalid credentials"
//     case .serverError:
//         return "Server error occurred"
//     case .unknown:
//         return "An unknown error occurred"
//     }
// }

// MARK: - Mock Social Service (Disabled - use SocialService.swift version)

// @MainActor
// class MockSocialService: ObservableObject, SocialServiceProtocol {
//     @Published var friends: [SocialUser] = []
    @Published var activeChallenges: [Challenge] = []
    @Published var leaderboards: [Leaderboard] = []
    @Published var activityFeed: [SocialActivity] = []
    @Published var isLoading: Bool = false
    @Published var error: SocialError?
    
    init() {
        Task {
            await loadMockData()
        }
    }
    
    func loadFriends() async {
        isLoading = true
        try? await Task.sleep(nanoseconds: 1_000_000_000) // 1 second delay
        
        friends = generateMockFriends()
        isLoading = false
    }
    
    func addFriend(username: String) async throws {
        isLoading = true
        try? await Task.sleep(nanoseconds: 500_000_000) // 0.5 second delay
        
        // Simulate potential errors
        if username.isEmpty {
            error = .userNotFound
            isLoading = false
            throw SocialError.userNotFound
        }
        
        let newFriend = SocialUser(
            username: username,
            displayName: username.capitalized,
            personalBest: Double.random(in: 4.2...6.5),
            totalSprints: Int.random(in: 5...100)
        )
        
        friends.append(newFriend)
        
        // Add activity
        let activity = SocialActivity(
            userId: newFriend.id,
            username: newFriend.username,
            displayName: newFriend.displayName,
            type: .friendRequest,
            title: "New Friend Added",
            description: "\(newFriend.displayName) is now your friend!"
        )
        activityFeed.insert(activity, at: 0)
        
        isLoading = false
    }
    
    func removeFriend(userId: UUID) async throws {
        friends.removeAll { $0.id == userId }
    }
    
    func loadChallenges() async {
        isLoading = true
        try? await Task.sleep(nanoseconds: 1_000_000_000)
        
        activeChallenges = generateMockChallenges()
        isLoading = false
    }
    
    func createChallenge(_ challenge: Challenge) async throws {
        activeChallenges.append(challenge)
    }
    
    func joinChallenge(challengeId: UUID) async throws {
        if let index = activeChallenges.firstIndex(where: { $0.id == challengeId }) {
            // Add current user to participants (mock user ID)
            let currentUserId = UUID()
            activeChallenges[index].participants.append(currentUserId)
        }
    }
    
    func loadLeaderboards() async {
        isLoading = true
        try? await Task.sleep(nanoseconds: 1_000_000_000)
        
        leaderboards = generateMockLeaderboards()
        isLoading = false
    }
    
    func loadActivityFeed() async {
        isLoading = true
        try? await Task.sleep(nanoseconds: 1_000_000_000)
        
        activityFeed = generateMockActivityFeed()
        isLoading = false
    }
    
    func markActivityAsRead(activityId: UUID) async {
        if let index = activityFeed.firstIndex(where: { $0.id == activityId }) {
            activityFeed[index].isRead = true
        }
    }
    
    // MARK: - Mock Data Generation
    
    private func loadMockData() async {
        await loadFriends()
        await loadChallenges()
        await loadLeaderboards()
        await loadActivityFeed()
    }
    
    private func generateMockFriends() -> [SocialUser] {
        let mockNames = ["SpeedDemon", "FastTrack", "RocketRun", "BlitzBolt", "TurboTime", "QuickSilver", "Lightning", "FlashRun"]
        
        return mockNames.map { name in
            SocialUser(
                username: name.lowercased(),
                displayName: name,
                personalBest: Double.random(in: 4.2...6.5),
                totalSprints: Int.random(in: 10...200),
                joinDate: Calendar.current.date(byAdding: .day, value: -Int.random(in: 1...365), to: Date()) ?? Date(),
                location: ["New York", "California", "Texas", "Florida", nil].randomElement() ?? nil
            )
        }
    }
    
    private func generateMockChallenges() -> [Challenge] {
        let challengeTypes = ChallengeType.allCases
        
        return challengeTypes.map { type in
            Challenge(
                title: type.displayName,
                description: type.description,
                type: type,
                status: .active,
                startDate: Calendar.current.date(byAdding: .day, value: -7, to: Date()) ?? Date(),
                endDate: Calendar.current.date(byAdding: .day, value: 7, to: Date()) ?? Date(),
                participants: Array(friends.prefix(Int.random(in: 2...5)).map { $0.id }),
                targetValue: type == .speed ? 4.5 : (type == .distance ? 1000 : 10),
                currentProgress: type == .speed ? Double.random(in: 4.5...5.5) : (type == .distance ? Double.random(in: 200...800) : Double.random(in: 3...8)),
                createdBy: friends.first?.id ?? UUID(),
                prize: ["Trophy", "Medal", "Gift Card", nil].randomElement() ?? nil
            )
        }
    }
    
    private func generateMockLeaderboards() -> [Leaderboard] {
        var leaderboards: [Leaderboard] = []
        
        for category in LeaderboardCategory.allCases {
            for timeframe in [LeaderboardTimeframe.weekly, LeaderboardTimeframe.monthly] {
                let entries = friends.enumerated().map { index, friend in
                    LeaderboardEntry(
                        userId: friend.id,
                        username: friend.username,
                        displayName: friend.displayName,
                        avatarURL: friend.avatarURL,
                        rank: index + 1,
                        score: generateScoreForCategory(category),
                        category: category,
                        timeframe: timeframe
                    )
                }
                
                leaderboards.append(Leaderboard(
                    category: category,
                    timeframe: timeframe,
                    entries: entries
                ))
            }
        }
        
        return leaderboards
    }
    
    private func generateScoreForCategory(_ category: LeaderboardCategory) -> Double {
        switch category {
        case .speed:
            return Double.random(in: 4.2...6.5)
        case .distance:
            return Double.random(in: 500...2000)
        case .improvement:
            return Double.random(in: 5...50)
        case .overall:
            return Double.random(in: 1000...5000)
        }
    }
    
    private func generateMockActivityFeed() -> [SocialActivity] {
        var activities: [SocialActivity] = []
        
        // Generate recent activities
        for i in 0..<10 {
            let friend = friends.randomElement() ?? friends.first!
            let activityType = SocialActivityType.allCases.randomElement()!
            let timestamp = Calendar.current.date(byAdding: .hour, value: -i, to: Date()) ?? Date()
            
            let (title, description) = generateActivityContent(type: activityType, user: friend)
            
            activities.append(SocialActivity(
                userId: friend.id,
                username: friend.username,
                displayName: friend.displayName,
                avatarURL: friend.avatarURL,
                type: activityType,
                title: title,
                description: description,
                timestamp: timestamp,
                isRead: Bool.random()
            ))
        }
        
        return activities.sorted { $0.timestamp > $1.timestamp }
    }
    
    private func generateActivityContent(type: SocialActivityType, user: SocialUser) -> (String, String) {
        switch type {
        case .friendRequest:
            return ("Friend Request", "\(user.displayName) wants to be your friend")
        case .challengeInvite:
            return ("Challenge Invite", "\(user.displayName) invited you to a challenge")
        case .personalBest:
            return ("New Personal Best!", "\(user.displayName) set a new PR: \(String(format: "%.2f", Double.random(in: 4.2...5.0))) sec")
        case .challengeCompleted:
            return ("Challenge Completed", "\(user.displayName) completed the Speed Challenge")
        case .rankImprovement:
            return ("Rank Improvement", "\(user.displayName) moved up to #\(Int.random(in: 1...10)) on the leaderboard")
        case .workoutCompleted:
            return ("Workout Complete", "\(user.displayName) completed a sprint session")
        }
    }
}
